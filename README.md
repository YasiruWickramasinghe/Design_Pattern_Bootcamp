# Design Patterns

## 1) Solid Principle

The SOLID principles are a set of design principles for object-oriented programming that aim to make code more maintainable, flexible, and reusable

### i) Single Responsibility Principle (SRP)
A class should have only one reason to change.

### ii) Open-Closed Principle (OCP)
Classes should be open for extension but closed for modification

### iii) SLiskov Substitution Principle (LSP)
Objects of a derived class should be substitutable for objects of the base class.

### iv) Interface Segregation Principle (ISP)
Clients should not be forced to depend on interfaces they do not use.

### v) Dependency Inversion Principle
Depend on abstractions, not concretions.

# Design Patterns Category

Explore this Java repository to understand and implement Creational, Structural, and Behavioral design patterns. Enhance your coding practices and build scalable, maintainable software using these proven principles.

## 1) Creational Design Patterns

### i) Singleton Pattern
Ensures a class has only one instance and provides a global point of access.

### ii) Factory Method Pattern
Defines an interface for creating an object but leaves the choice of its type to the subclasses.

### iii) Abstract Factory Pattern
Provides an interface for creating families of related or dependent objects without specifying their concrete classes.

### iv) Prototype Pattern
Creates new objects by copying an existing object, known as the prototype.

### v) Builder Pattern
Separates the construction of a complex object from its representation, allowing the same construction process to create different representations.

## 2) Structural Design Patterns

### i) Adapter Pattern
Allows the interface of an existing class to be used as another interface.

### ii) Decorator Pattern
Attaches additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality.

### iii) Composite Pattern
Composes objects into tree structures to represent part-whole hierarchies. Clients can treat individual objects and compositions of objects uniformly.

## 3) Behavioral Design Patterns

### i) Observer Pattern
Defines a one-to-many dependency between objects, so that when one object changes state, all its dependents are notified and updated automatically.

### ii) Strategy Pattern
Defines a family of algorithms, encapsulates each algorithm, and makes them interchangeable. Clients can choose the appropriate algorithm at runtime.

